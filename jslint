#!/usr/bin/env node

/*jslint
    es6, node
*/

function highlight(str) {
    "use strict";
    return "\x1B[7m" + str + "\x1B[27m";
}

function highlightCol(str, i) {
    "use strict";
    var c = str.charAt(i);
    var code = str.charCodeAt(i);
    var codeOther;
    var before;
    var middle;
    var after;

    // Handle non-BMP characters
    if (code >= 0xD800 && code <= 0xDBFF) {
        codeOther = str.charCodeAt(i + 1);
        if (codeOther >= 0xDC00 && codeOther <= 0xDFFF) {
            middle = highlight(c + str.charAt(i + 1));
            after = str.slice(i + 2);
        }
    } else if (code >= 0xDC00 && code <= 0xDFFF && i !== 0) {
        codeOther = str.charCodeAt(i - 1);
        if (codeOther >= 0xD800 && codeOther <= 0xDBFF) {
            before = str.slice(0, i - 1);
            middle = highlight(str.charAt(i - 1) + c);
        }
    }

    before = before || str.slice(0, i);
    middle = middle || highlight(c);
    after = after || str.slice(i + 1);
    return before + middle + after;
}

function paddedNumber(totalSpace, number) {
    "use strict";

    var digitString = number.toString();
    var padding = totalSpace - digitString.length;
    var space = " ";

    if (padding >= 0) {
        return space.repeat(padding) + digitString;
    } else {
        return digitString;
    }
}

function displayErrors(path, data) {
    "use strict";

    var fudge = +!!data.option.fudge;
    var maxLine;
    var maxLineDigits;
    var maxerr = data.option.maxerr;
    var numberOfWarnings = data.warnings.length;
    var tooMany = numberOfWarnings >= maxerr;
    var tooManyNumber = numberOfWarnings - tooMany;
    var tooManyNumberDigits = tooManyNumber.toString().length;
    var unable = "JSLint was unable to finish.";

    if (numberOfWarnings !== 0) {
        console.log("\n%s", path);
        maxLine = data.warnings[numberOfWarnings - 1].line + fudge;
        maxLineDigits = maxLine.toString().length;
    }
    data.warnings.forEach(function (warning, i) {
        var message = warning.message;
        var messageCol;
        var messageColHi;
        var messageLine;
        var messageLineHi;
        var messageNum;

        if (i === maxerr && data.stop) {
            console.log(" ", message, unable);
        } else {
            messageCol = warning.column;
            messageColHi = highlightCol(data.lines[warning.line], messageCol);
            messageLine = warning.line + fudge;
            messageLineHi = highlight(paddedNumber(maxLineDigits, messageLine));
            messageNum = paddedNumber(tooManyNumberDigits, i + 1);
            console.log("  #%s %s", messageNum, message);
            console.log("  %s %s", messageLineHi, messageColHi);
        }
    });
    if (data.stop && !tooMany) {
        console.log(" ", unable);
    }
}

function extend(obj, newProp) {
    "use strict";

    var newObj = {};
    Object.keys(obj).forEach(function (key) {
        newObj[key] = obj[key];
    });
    Object.keys(newProp).forEach(function (key) {
        newObj[key] = newProp[key];
    });
    return newObj;
}

function notBool(key) {
    "use strict";
    throw new Error("'" + key + "' must have a Boolean value.");
}

function notKnown(key) {
    "use strict";
    throw new Error("Unexpected option: '" + key + "'.");
}

function notNum(key) {
    "use strict";
    throw new Error("'" + key + "' must have a numeric value.");
}

function unexpectedValue(key) {
    "use strict";
    throw new Error("'" + key + "' does not expect a value.");
}

var optErr = {
    notBool: notBool,
    notKnown: notKnown,
    notNum: notNum,
    unexpectedValue: unexpectedValue
};

function parseCommandLineArgs(argv) {
    "use strict";
    var key;
    var match;
    var notStop = true;
    var num;
    var optRegEx = /^--([^\s=]+)(?:=(\S*))?$/;
    var value;

    return argv.reduce(function (conf, arg) {
        if (notStop) {
            if (arg === "--") {
                notStop = false;
                return conf;
            }

            match = arg.match(optRegEx);
            if (match) {
                key = match[1];
                value = match[2];
                switch (key) {
                case "bitwise":
                case "browser":
                case "couch":
                case "devel":
                case "es6":
                case "eval":
                case "for":
                case "fudge":
                case "node":
                case "this":
                case "white":
                    switch (value) {
                    case "true":
                    case undefined:
                        conf.options[key] = true;
                        break;
                    case "false":
                        conf.options[key] = false;
                        break;
                    default:
                        optErr.notBool(key);
                    }
                    return conf;
                case "maxerr":
                case "maxlen":
                    num = Number.parseInt(value);
                    if (Number.isNaN(num)) {
                        optErr.notNum(key);
                    }
                    conf.options[key] = num;
                    return conf;
                case "raw":
                case "sha-bang":
                    if (value !== undefined) {
                        optErr.unexpectedValue(key);
                    }
                    conf.flags[key] = true;
                    return conf;
                default:
                    optErr.notKnown(key);
                }
            }
        }

        conf.filePaths.push(arg);
        return conf;
    }, {
        filePaths: [],
        flags: {
            raw: false,
            "sha-bang": false
        },
        options: {}
    });
}

function parseConfigurations(oldConfObj, str) {
    "use strict";
    var newConfObj = JSON.parse(str);

    Object.keys(newConfObj).forEach(function isValidOption(key) {
        switch (key) {
        case "bitwise":
        case "browser":
        case "couch":
        case "devel":
        case "es6":
        case "eval":
        case "for":
        case "fudge":
        case "node":
        case "this":
        case "white":
            if (typeof newConfObj[key] !== "boolean") {
                optErr.notBool(key);
            }
            break;
        case "maxerr":
        case "maxlen":
            if (typeof newConfObj[key] !== "number") {
                optErr.notNum(key);
            }
            break;
        default:
            optErr.notKnown(key);
        }
    });

    if (oldConfObj && typeof oldConfObj === "object") {
        return extend(oldConfObj, newConfObj);
    }

    return newConfObj;
}

var Node = Object.freeze({
    fs: require("fs"),
    jslint: require("./index").jslint,
    path: require("path")
});

var confFile = ".jslintrc";

function readFile(filename, options) {
    "use strict";
    return new Promise(function (resolve, reject) {
        Node.fs.readFile(filename, options, function (err, data) {
            if (err) {
                reject(err);
            } else {
                resolve(data);
            }
        });
    });
}

// Promise to read "pathname" and use it to update oldConf.
// If "pathname" is a directory, read "pathname/.jslintrc" instead.
function readConf(pathname, oldConf) {
    "use strict";
    return readFile(pathname, "utf8")
        .catch(function (err) {
            if (err.code === "EISDIR") {
                return readFile(Node.path.join(pathname, confFile), "utf8");
            }
            throw err;
        })
        .then(parseConfigurations.bind(undefined, oldConf))
        .catch(function (err) {
            if (err.code === "ENOENT") {
                return oldConf;
            }
            throw err;
        });
}

function readConfs(pathnames, oldConf) {
    "use strict";
    return pathnames
        .reduce((prom, path) => prom.then(readConf.bind(undefined, path)),
                Promise.resolve(oldConf));
}

// Promise to read configuration files from basePath to path.
function readProjConfs(baseDir, dir, oldConf) {
    "use strict";

    var splitPath = Node.path.relative(baseDir, dir).split(Node.path.sep);

    // dir is not in baseDir subtree.
    if (splitPath[0] === "..") {
        return Promise.resolve(oldConf);
    }

    // baseDir is the same as dir.
    if (splitPath[0] === "") {
        return readConf(dir, oldConf);
    }

    // dir is in baseDir subtree.
    return readConfs(splitPath
        .reduce((prev, elem, ix) => prev.concat(Node.path.join(prev[ix], elem)),
                ["."]),
            oldConf);
}

var P = Object.freeze({
    readConf: readConf,
    readProjConfs: readProjConfs,
    readFile: readFile
});

var cwd = process.cwd();
var flags;
var filePaths;
var homeDir;
var cmdLineOpts;
var parsedArgs;

function printErrorAndExit(err) {
    "use strict";
    console.error(err.toString());
    process.exit(1);
}

try {
    parsedArgs = parseCommandLineArgs(process.argv.slice(2));
} catch (err) {
    printErrorAndExit(err);
}

filePaths = parsedArgs.filePaths;
cmdLineOpts = parsedArgs.options;
flags = parsedArgs.flags;

if (process.platform !== "win32") {
    homeDir = process.env.HOME;
} else {
    homeDir = process.env.USERPROFILE;
}

if (filePaths.length === 0) {
    printErrorAndExit("No files specified.");
}

function removeShaBang(str, shaBang) {
    "use strict";
    if (shaBang) {
        return str.replace(/^#!.*(\n|\r\n?)/, "");
    }
    return str;
}

function lintFile(homeConf, file, prevReport) {
    "use strict";
    return P.readFile(file, "utf8")
        .then(function (data) {
            return P.readProjConfs(cwd, Node.path.dirname(file), homeConf)
                .then(function (conf) {
                    var newConf = extend(conf, cmdLineOpts);
                    var report = Node
                        .jslint(removeShaBang(data, flags["sha-bang"]),
                                newConf);

                    if (flags.raw) {
                        return prevReport.concat({
                            file: file,
                            option: report.option,
                            stop: report.stop,
                            warnings: report.warnings
                        });
                    }
                    displayErrors(file, report);
                });
        });
}

P.readConf(homeDir, {})
    .then(function (conf) {
        "use strict";
        var promise = filePaths.reduce(function (prom, file) {
            return prom.then(lintFile.bind(undefined, conf, file));
        }, Promise.resolve([]));
        if (flags.raw) {
            return promise.then(function (out) {
                process.stdout.write(JSON.stringify(out));
            });
        }
        return promise;
    })
    .catch(printErrorAndExit);
