#!/usr/bin/env node

/*jslint
    es6, node
*/

"use strict";

function highlight(str) {
    return "\x1B[7m" + str + "\x1B[27m";
}

function highlightCol(str, i) {
    var c = str.charAt(i);
    var code = str.charCodeAt(i);
    var codeOther;
    var before;
    var middle;
    var after;

    // Handle non-BMP characters
    if (code >= 0xD800 && code <= 0xDBFF) {
        codeOther = str.charCodeAt(i + 1);
        if (codeOther >= 0xDC00 && codeOther <= 0xDFFF) {
            middle = highlight(c + str.charAt(i + 1));
            after = str.slice(i + 2);
        }
    } else if (code >= 0xDC00 && code <= 0xDFFF && i !== 0) {
        codeOther = str.charCodeAt(i - 1);
        if (codeOther >= 0xD800 && codeOther <= 0xDBFF) {
            before = str.slice(0, i - 1);
            middle = highlight(str.charAt(i - 1) + c);
        }
    }

    before = before || str.slice(0, i);
    middle = middle || highlight(c);
    after = after || str.slice(i + 1);
    return before + middle + after;
}

function paddedNumber(totalSpace, number) {
    var digitString = number.toString();
    var padding = totalSpace - digitString.length;
    var space = " ";

    if (padding >= 0) {
        return space.repeat(padding) + digitString;
    } else {
        return digitString;
    }
}

function displayErrors(path, data) {
    var fudge = +!!data.option.fudge;
    var maxLine;
    var maxLineDigits;
    var maxerr = data.option.maxerr;
    var numberOfWarnings = data.warnings.length;
    var tooMany = numberOfWarnings >= maxerr;
    var tooManyNumber = numberOfWarnings - tooMany;
    var tooManyNumberDigits = tooManyNumber.toString().length;
    var unable = "JSLint was unable to finish.";

    if (numberOfWarnings !== 0) {
        console.log("\n%s", path);
        maxLine = data.warnings[numberOfWarnings - 1].line + fudge;
        maxLineDigits = maxLine.toString().length;
    }
    data.warnings.forEach(function (warning, i) {
        var message = warning.message;
        var messageCol;
        var messageColHi;
        var messageLine;
        var messageLineHi;
        var messageNum;

        if (i === maxerr && data.stop) {
            console.log(" ", message, unable);
        } else {
            messageCol = warning.column;
            messageColHi = highlightCol(data.lines[warning.line], messageCol);
            messageLine = warning.line + fudge;
            messageLineHi = highlight(paddedNumber(maxLineDigits, messageLine));
            messageNum = paddedNumber(tooManyNumberDigits, i + 1);
            console.log("  #%s %s", messageNum, message);
            console.log("  %s %s", messageLineHi, messageColHi);
        }
    });
    if (data.stop && !tooMany) {
        console.log(" ", unable);
    }
}

function parseCommandLineArgs(argv) {
    var key;
    var match;
    var notStop = true;
    var num;
    var optRegEx = /^--([^\s=]+)(?:=(\S*))?$/;
    var value;

    return argv.reduce(function (conf, arg) {
        if (notStop) {
            if (arg === "--") {
                notStop = false;
                return conf;
            }

            match = arg.match(optRegEx);
            if (match) {
                key = match[1];
                value = match[2];
                switch (key) {
                case "bitwise":
                case "browser":
                case "couch":
                case "devel":
                case "es6":
                case "eval":
                case "for":
                case "fudge":
                case "multivar":
                case "node":
                case "single":
                case "this":
                case "white":
                    switch (value) {
                    case "true":
                    case undefined:
                        conf.options[key] = true;
                        break;
                    case "false":
                        conf.options[key] = false;
                        break;
                    default:
                        throw new Error("'" + key + "' must have a Boolean value.");
                    }
                    return conf;
                case "maxerr":
                case "maxlen":
                    num = Number.parseInt(value);
                    if (Number.isNaN(num)) {
                        throw new Error("'" + key + "' must have a numeric value.");
                    }
                    conf.options[key] = num;
                    return conf;
                case "raw":
                case "sha-bang":
                case "version":
                    if (value !== undefined) {
                        throw new Error("'" + key + "' does not expect a value.");
                    }
                    conf.flags[key] = true;
                    return conf;
                default:
                    throw new Error("Unexpected option: '" + key + "'.");
                }
            }
        }

        conf.filePaths.push(arg);
        return conf;
    }, {
        filePaths: [],
        flags: {
            raw: false,
            "sha-bang": false,
            version: false
        },
        options: {}
    });
}

const {jslintEdition, jslintFile} = require("./index");
var flags;
var filePaths;
var cmdLineOpts;
var parsedArgs;

function printErrorAndExit(err) {
    console.error(err.toString());
    process.exit(1);
}

try {
    parsedArgs = parseCommandLineArgs(process.argv.slice(2));
} catch (err) {
    printErrorAndExit(err);
}

filePaths = parsedArgs.filePaths;
cmdLineOpts = parsedArgs.options;
flags = parsedArgs.flags;

if (flags.version) {
    const version = require("./package.json").version;
    if (flags.raw) {
        process.stdout.write(JSON.stringify({
            version: version,
            jslintEdition: jslintEdition
        }));
    } else {
        console.log("jslint (JSLinter) %s (JSLint edition %s)",
                version, jslintEdition);
        console.log("Copyright (c) 2015-2016 Nicola Squartini");
    }
    process.exit(0);
}

if (filePaths.length === 0) {
    printErrorAndExit("No files specified.");
}

jslintFile(filePaths, {
    callback: flags.raw
        ? function ({pathname, report}) {
            return {
                file: pathname,
                option: report.option,
                stop: report.stop,
                warnings: report.warnings
            };
        }
        : function ({pathname, report}) {
            displayErrors(pathname, report);
        },
    options: cmdLineOpts,
    shaBang: flags["sha-bang"]
}).then(function (out) {
    if (flags.raw) {
        process.stdout.write(JSON.stringify(out));

    }
}).catch(printErrorAndExit);
